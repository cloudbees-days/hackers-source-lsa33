apiVersion: automation.cloudbees.io/v1alpha1
kind: workflow
name: Main workflow
on:
  push:
    branches:
      - "**"
  workflow_dispatch:
permissions:
  scm-token-own: read
  scm-token-org: read
  id-token: write
env:
  APP_NAME: hackers-organized
  NAMESPACE: lsa33
jobs:
  test:
    outputs:
      CODE_COVERAGE: ${{ steps.RunUnitTest.outputs.CODE_COVERAGE }}
    steps:
      - uses: cloudbees-io/checkout@v1
        name: Get source code
        continue-on-error: true
      - name: Run unit tests
        id: RunUnitTest
        kind: test
        uses: docker://node:lts
        run: |
          npm ci --no-audit
          npm run test:unit
          npx jest --coverage >> $CLOUDBEES_OUTPUTS/CODE_COVERAGE
      - name: Publish test results
        uses: cloudbees-io/publish-test-results@v1
        with:
          test-type: JUnit
          folder-name: ${{ cloudbees.workspace }}/junit.xml
      - name: Publish evidence
        uses: cloudbees-io/publish-evidence-item@v1
        with:
          content: |-
            ## Test code coverage
            ${{ steps.RunUnitTest.outputs.CODE_COVERAGE }}
          format: MARKDOWN
          
  build-and-push-nexus-curl:
    steps:
      - uses: cloudbees-io/checkout@v1
        name: Get source code
        kind: build
      - uses: docker://docker:latest
        name: Build and extract Docker image
        run: |
          apk add --no-cache tar gzip curl jq coreutils
          docker build -t hackers-organized:${{ cloudbees.scm.sha }} .
          docker save hackers-organized:${{ cloudbees.scm.sha }} -o image.tar
          mkdir image_dir && tar -xf image.tar -C image_dir
          jq -r '.[0].Config' image_dir/manifest.json > config_name
          cp image_dir/$(cat config_name) config.json
          jq -r '.[0].Layers[]' image_dir/manifest.json > layers.txt
          while read layer; do cp image_dir/$layer $(basename $layer); done < layers.txt
      - uses: docker://alpine:latest
        name: Push to Nexus via CURL
        run: |
          apk add --no-cache curl jq bash coreutils
          USERNAME=lsa26
          PASSWORD=${{ secrets.NEXUS_PASSWORD_LSA26 }}
          # Correction: Vérifier les deux ports possibles
          REGISTRY=nexus.cloudbees.guru:8081
          REPO=unify-docker-lsa26/hackers-organized
          TAG=${{ cloudbees.scm.sha }}
          
          echo "Vérification de l'existence du dépôt et de la connexion..."
          # Vérifier si le repo existe et si les identifiants sont bons
          CATALOG_RESPONSE=$(curl -sS -v -u $USERNAME:$PASSWORD https://$REGISTRY/v2/_catalog 2>&1)
          echo "Réponse du catalogue:"
          echo "$CATALOG_RESPONSE"
          
          if echo "$CATALOG_RESPONSE" | grep -q "401 Unauthorized"; then
            echo "ERREUR: Authentification échouée. Veuillez vérifier vos identifiants."
            exit 1
          fi

          sha256_digest() { sha256sum $1 | awk '{print $1}'; }
          push_blob() {
            FILE=$1
            DIGEST=sha256:$(sha256_digest $FILE)
            echo "Envoi du blob: $FILE (digest: $DIGEST)"
            UPLOAD_RESPONSE=$(curl -sS -v -u $USERNAME:$PASSWORD -X POST -i https://$REGISTRY/v2/$REPO/blobs/uploads/ 2>&1)
            echo "Réponse de l'initialisation de l'upload:"
            echo "$UPLOAD_RESPONSE"
            
            URL=$(echo "$UPLOAD_RESPONSE" | grep -Fi Location | awk '{print $2}' | tr -d '\r')
            
            if [ -z "$URL" ]; then
              echo "ERREUR: Impossible d'obtenir l'URL d'upload. Vérifiez que le repo existe."
              echo "Essai avec le port 8082..."
              REGISTRY=nexus.cloudbees.guru:8082
              UPLOAD_RESPONSE=$(curl -sS -v -u $USERNAME:$PASSWORD -X POST -i https://$REGISTRY/v2/$REPO/blobs/uploads/ 2>&1)
              URL=$(echo "$UPLOAD_RESPONSE" | grep -Fi Location | awk '{print $2}' | tr -d '\r')
              
              if [ -z "$URL" ]; then
                echo "ERREUR: Échec avec le port 8082 également."
                exit 1
              else
                echo "Port 8082 fonctionne, utilisation de ce port pour la suite."
              fi
            fi
            
            echo "URL d'upload obtenue: $URL"
            PUSH_RESPONSE=$(curl -sS -v -u $USERNAME:$PASSWORD -X PUT "$URL&digest=$DIGEST" --data-binary @$FILE -H "Content-Type: application/octet-stream" 2>&1)
            echo "Réponse de l'upload du blob:"
            echo "$PUSH_RESPONSE"
          }

          echo "Envoi du fichier de configuration..."
          push_blob config.json
          echo "Envoi des couches de l'image..."
          for f in *.tar.gz *.tar; do 
            if [ -f "$f" ]; then
              echo "Traitement de la couche: $f"
              push_blob $f
            fi
          done

          CONFIG_DIGEST=sha256:$(sha256_digest config.json)
          echo "Digest du fichier de configuration: $CONFIG_DIGEST"
          
          LAYERS_JSON=$(for f in *.tar.gz *.tar; do 
            if [ -f "$f" ]; then
              echo "{\"mediaType\": \"application/vnd.docker.image.rootfs.diff.tar.gzip\", \"size\": $(stat -c%s $f), \"digest\": \"sha256:$(sha256_digest $f)\"},"
            fi
          done | sed '$ s/,$//')
          
          echo "JSON des couches: $LAYERS_JSON"

          # Création du manifest JSON
          cat > manifest.json << EOF
          {
            "schemaVersion": 2,
            "mediaType": "application/vnd.docker.distribution.manifest.v2+json",
            "config": {
              "mediaType": "application/vnd.docker.container.image.v1+json",
              "size": $(stat -c%s config.json),
              "digest": "$CONFIG_DIGEST"
            },
            "layers": [
              $LAYERS_JSON
            ]
          }
          EOF
          
          echo "Manifest créé:"
          cat manifest.json

          # Envoi du manifest à Nexus
          echo "Envoi du manifest..."
          MANIFEST_RESPONSE=$(curl -sS -v -u $USERNAME:$PASSWORD -X PUT \
            -H "Content-Type: application/vnd.docker.distribution.manifest.v2+json" \
            --data-binary @manifest.json \
            https://$REGISTRY/v2/$REPO/manifests/$TAG 2>&1)
          
          echo "Réponse de l'envoi du manifest:"
          echo "$MANIFEST_RESPONSE"
          
          # Vérification du résultat
          if echo "$MANIFEST_RESPONSE" | grep -q "201 Created"; then
            echo "✅ Image poussée avec succès à $REGISTRY/v2/$REPO:$TAG"
          else
            echo "❌ Échec de l'envoi de l'image. Vérifiez les logs ci-dessus pour les détails."
            exit 1
          fi

      - name: Confirm Nexus upload success
        uses: cloudbees-io/publish-evidence-item@v1
        with:
          content: |-
            ## Image pushed to Nexus with CURL
            - **Registry**: nexus.cloudbees.guru:8081 ou 8082 (détecté automatiquement)
            - **Repository**: unify-docker-lsa26/hackers-organized
            - **Tag**: ${{ cloudbees.scm.sha }}
            - ✅ Uploaded with raw API requests using curl
          format: MARKDOWN
    needs: test
  
  scan:
    outputs:
      BLOCKER_COUNT: ${{ steps.FetchSonarQubeIssues.outputs.BLOCKER_COUNT }}
      CRITICAL_COUNT: ${{ steps.FetchSonarQubeIssues.outputs.CRITICAL_COUNT }}
      MAJOR_COUNT: ${{ steps.FetchSonarQubeIssues.outputs.MAJOR_COUNT }}
      MINOR_COUNT: ${{ steps.FetchSonarQubeIssues.outputs.MINOR_COUNT }}
    steps:
      - name: Checkout
        uses: cloudbees-io/checkout@v1
      - name: Get code coverage
        kind: test
        uses: docker://node:lts
        run: |
          npm ci --no-audit
          npm run test:coverage
      - uses: cloudbees-io/sonarqube-bundled-sast-scan-code@v1
        name: Scan with SonarQube
        kind: scan
        continue-on-error: true
        with:
          language: LANGUAGE_JS
          cover-file-name: coverage/clover.xml
          sonar-exclusion: tests/*
      - uses: cloudbees-io/snyk-sast-scan-code@v1
        name: Synk SAST
        kind: scan
        continue-on-error: true
        with:
          orgname: ${{ secrets.SNYK_ORGNAME }}
          token: ${{ secrets.SNYK_TOKEN }}
          language: LANGUAGE_JS
          additional-args: "--skip=npm-audit"
      - name: Scan with Snyk SCA
        uses: cloudbees-io/snyk-sca-scan-dependency@v1
        continue-on-error: true
        with:
          orgname: ${{ secrets.SNYK_ORGNAME }}
          token: ${{ secrets.SNYK_TOKEN }}
          language: LANGUAGE_JS
          additional-args: "--skip=npm-audit"
      - name: Fetch SonarQube Issues
        id: FetchSonarQubeIssues
        uses: docker://alpine/git:latest
        run: |
          apk add --no-cache curl jq
          curl -u ${{ secrets.SONAR_USER }}:${{ secrets.SONAR_TOKEN }} \
          "https://sonarqube.cb-demos.io/api/issues/search?componentKeys=HackersOrganized&severities=BLOCKER,CRITICAL,MAJOR,MINOR" \
          -o sonar-issues.json
          BLOCKER_COUNT=$(jq '[.issues[] | select(.severity=="BLOCKER")] | length' sonar-issues.json)
          CRITICAL_COUNT=$(jq '[.issues[] | select(.severity=="CRITICAL")] | length' sonar-issues.json)
          MAJOR_COUNT=$(jq '[.issues[] | select(.severity=="MAJOR")] | length' sonar-issues.json)
          MINOR_COUNT=$(jq '[.issues[] | select(.severity=="MINOR")] | length' sonar-issues.json)

          echo "${BLOCKER_COUNT}" >> $CLOUDBEES_OUTPUTS/BLOCKER_COUNT
          echo "${CRITICAL_COUNT}" >> $CLOUDBEES_OUTPUTS/CRITICAL_COUNT
          echo "${MAJOR_COUNT}" >> $CLOUDBEES_OUTPUTS/MAJOR_COUNT
          echo "${MINOR_COUNT}" >> $CLOUDBEES_OUTPUTS/MINOR_COUNT
      - name: Publish evidence
        uses: cloudbees-io/publish-evidence-item@v1
        with:
          content: |-
            ## SonarQube Analysis Results

            | Severity             | Issue Count |
            |----------------------|-------------|
            | BLOCKER_COUNT        | ${{ steps.FetchSonarQubeIssues.outputs.BLOCKER_COUNT }} |
            | CRITICAL_COUNT       | ${{ steps.FetchSonarQubeIssues.outputs.CRITICAL_COUNT }} |
            | MAJOR_COUNT          | ${{ steps.FetchSonarQubeIssues.outputs.MAJOR_COUNT }} |
            | MINOR_COUNT          | ${{ steps.FetchSonarQubeIssues.outputs.MINOR_COUNT }} |
          format: MARKDOWN
          
  deploy:
    environment: lsa33
    steps:
      - name: Checkout
        uses: cloudbees-io/checkout@v1
      - uses: cashokannamalai/kubeconfig@v1
        name: Set kubeconfig
        with:
          secname: ${{ secrets.kubeconfig }}
      - id: install-chart
        name: Install helm chart
        uses: cloudbees-io/helm-install@v1
        with:
          chart-location: ${{ cloudbees.workspace }}/chart
          release-name: ${{ env.APP_NAME }}
          namespace: ${{ env.NAMESPACE }}
          values: |
            image:
              repository: nexus.cloudbees.guru:8081/unify-docker-lsa26/hackers-organized
              tag: ${{ cloudbees.scm.sha }}
            fmKey: ${{ secrets.FM_TOKEN }}
            hostname: ${{ env.APP_NAME }}-${{ env.NAMESPACE }}.preview.cb-demos.io
      - name: Publish evidence
        uses: cloudbees-io/publish-evidence-item@v1
        with:
          content: |-
            ## Deployed environment
            [Production frontend](https://${{ env.APP_NAME }}-${{ env.NAMESPACE }}.preview.cb-demos.io/)

            Running hackers-organized:${{ cloudbees.scm.sha }} from Nexus registry
          format: MARKDOWN
      - name: Register_deployed_artifact
        uses: https://github.com/cloudbees-io/register-deployed-artifact@v1
        with:
          name: nexus.cloudbees.guru:8081/unify-docker-lsa26/hackers-organized
          version: ${{ cloudbees.scm.sha }}
          url: nexus.cloudbees.guru:8081/unify-docker-lsa26/hackers-organized:${{ cloudbees.scm.sha }}
          digest: ""
          target-environment: lsa33
    needs:
      - build-and-push-nexus-curl
      - scan