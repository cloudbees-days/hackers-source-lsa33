apiVersion: automation.cloudbees.io/v1alpha1
kind: workflow
name: Main workflow
on:
  push:
    branches:
      - "**"
  workflow_dispatch:
permissions:
  scm-token-own: read
  scm-token-org: read
  id-token: write
env:
  APP_NAME: hackers-organized
  NAMESPACE: lsa33
  DOCKER_REGISTRY: nexus.cloudbees.guru:8081
  DOCKER_REPO: repository/unify-docker-lsa26
jobs:
  test:
    outputs:
      CODE_COVERAGE: ${{ steps.RunUnitTest.outputs.CODE_COVERAGE }}
    steps:
      - uses: cloudbees-io/checkout@v1
        name: Get source code
        continue-on-error: true
      - name: Run unit tests
        id: RunUnitTest
        kind: test
        uses: docker://node:lts
        run: |
          npm ci --no-audit
          npm run test:unit
          npx jest --coverage >> $CLOUDBEES_OUTPUTS/CODE_COVERAGE
      - name: Publish test results
        uses: cloudbees-io/publish-test-results@v1
        with:
          test-type: JUnit
          folder-name: ${{ cloudbees.workspace }}/junit.xml
      - name: Publish evidence
        uses: cloudbees-io/publish-evidence-item@v1
        with:
          content: |-
            ## Test code coverage
            ${{ steps.RunUnitTest.outputs.CODE_COVERAGE }}
          format: MARKDOWN
          
  build-and-push-nexus:
    steps:
      - uses: cloudbees-io/checkout@v1
        name: Get source code
        kind: build
        continue-on-error: true
      # On utilisera buildkit directement dans un conteneur Node pour construire l'image
      - uses: docker://node:lts
        name: Build image directly
        run: |
          # Installation des d√©pendances et build de l'application
          npm ci --no-audit
          npm run build
          
          # Cr√©ation d'une image minimaliste manuellement
          mkdir -p /tmp/docker-build
          cd /tmp/docker-build
          
          # Copier les fichiers n√©cessaires
          mkdir -p usr/share/nginx/html
          cp -r $CLOUDBEES_WORKSPACE/dist/* usr/share/nginx/html/
          
          # Cr√©er le tarball pour Nexus
          tar -cf /tmp/image.tar ./usr
          gzip -9 /tmp/image.tar
          
          # Cr√©er un fichier de configuration minimaliste pour l'image Docker
          echo '{
            "architecture": "amd64",
            "config": {
              "Hostname": "",
              "Env": ["PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"],
              "Cmd": ["nginx", "-g", "daemon off;"],
              "WorkingDir": "/",
              "ExposedPorts": {"80/tcp": {}}
            },
            "rootfs": {
              "type": "layers",
              "diff_ids": []
            }
          }' > /tmp/config.json
          
          # Cr√©er les fichiers n√©cessaires pour le Nexus push
          cp /tmp/image.tar.gz $CLOUDBEES_WORKSPACE/
          cp /tmp/config.json $CLOUDBEES_WORKSPACE/
      
      # Pousser l'image vers Nexus
      - uses: docker://alpine:latest
        id: push-to-nexus
        name: Push to Nexus via CURL
        run: |
          # Ne pas arr√™ter imm√©diatement en cas d'erreur pour voir les messages d'erreur
          set +e
          apk add --no-cache curl jq tar gzip coreutils
          
          USERNAME=lsa26
          PASSWORD=${{ secrets.NEXUS_PASSWORD_LSA26 }}
          REGISTRY=${{ env.DOCKER_REGISTRY }}
          REPO_PATH=${{ env.DOCKER_REPO }}
          IMAGE_NAME=${{ env.APP_NAME }}
          TAG=${{ cloudbees.scm.sha }}
          
          # V√©rifier les fichiers
          echo "üìÇ V√©rification des fichiers:"
          ls -la
          
          # Test de connexion √† Nexus avec diff√©rents chemins
          echo "üì° Test des chemins API possibles..."
          
          TEST_PATHS=(
            "v2/"
            "v2/_catalog"
            "repository/v2/"
            "v2/unify-docker-lsa26/"
          )
          
          for path in "${TEST_PATHS[@]}"; do
            echo "üîç Test du chemin: https://$REGISTRY/$path"
            RESPONSE=$(curl -s -f -u $USERNAME:$PASSWORD https://$REGISTRY/$path 2>&1)
            if [ $? -eq 0 ]; then
              echo "‚úÖ Chemin valide: $path"
              echo "$RESPONSE"
            else
              echo "‚ùå Chemin invalide: $path"
            fi
          done
          
          # Fonction pour calculer le digest SHA256
          sha256_digest() { sha256sum "$1" | awk '{print $1}'; }
          
          # Fonction pour pousser un blob vers Nexus avec diff√©rents chemins possibles
          push_blob() {
            local FILE=$1
            local DIGEST=sha256:$(sha256_digest "$FILE")
            echo "üì§ Pouss√©e du blob $FILE (SHA256:$DIGEST)..."
            
            # V√©rifier si le fichier existe
            if [ ! -f "$FILE" ]; then
              echo "‚ùå Erreur: Le fichier $FILE n'existe pas!"
              ls -la
              return 1
            fi
            
            echo "üì¶ Taille du fichier: $(du -h "$FILE")"
            
            # Essayer diff√©rents chemins d'API
            local API_PATHS=(
              "$REPO_PATH/v2/blobs/uploads/"
              "v2/$REPO_PATH/blobs/uploads/"
              "v2/unify-docker-lsa26/blobs/uploads/"
            )
            
            local success=false
            
            for api_path in "${API_PATHS[@]}"; do
              echo "üîÑ Essai avec le chemin API: $api_path"
              
              # Initialisation de l'upload
              local INIT_RESPONSE=$(curl -v -u $USERNAME:$PASSWORD -X POST \
                "https://$REGISTRY/$api_path" 2>&1)
              
              echo "üîç R√©ponse d'initialisation:"
              echo "$INIT_RESPONSE"
              
              # Chercher l'URL d'upload de diff√©rentes mani√®res
              local UPLOAD_URL=""
              UPLOAD_URL=$(echo "$INIT_RESPONSE" | grep -i "Location:" | head -1 | awk '{print $2}' | tr -d '\r')
              
              if [ -n "$UPLOAD_URL" ]; then
                echo "üîó URL d'upload trouv√©e: $UPLOAD_URL"
                
                # Upload du blob
                echo "üì§ Upload du blob..."
                local UPLOAD_RESPONSE=$(curl -v -u $USERNAME:$PASSWORD -X PUT \
                  "${UPLOAD_URL}&digest=$DIGEST" \
                  --data-binary @"$FILE" 2>&1)
                
                echo "üîç R√©ponse d'upload:"
                echo "$UPLOAD_RESPONSE"
                
                # V√©rifier si l'upload a r√©ussi
                if echo "$UPLOAD_RESPONSE" | grep -q "201 Created"; then
                  echo "‚úÖ Blob upload√© avec succ√®s via $api_path"
                  success=true
                  break
                fi
              fi
            done
            
            if [ "$success" != true ]; then
              echo "‚ùå √âchec de l'upload du blob apr√®s avoir essay√© tous les chemins"
              return 1
            fi
            
            # Retourner le digest sans le pr√©fixe sha256:
            echo "${DIGEST#sha256:}"
          }
          
          # Pousser le fichier image.tar.gz
          echo "üöÄ Pouss√©e de la couche d'image..."
          IMAGE_LAYER_DIGEST=$(push_blob image.tar.gz)
          
          # V√©rifier si le push a r√©ussi
          if [ $? -ne 0 ]; then
            echo "‚ùå √âchec lors de la pouss√©e de la couche d'image"
            exit 1
          fi
          
          echo "‚úÖ Image layer digest: $IMAGE_LAYER_DIGEST"
          
          # Pousser la configuration
          echo "üöÄ Pouss√©e de la configuration..."
          CONFIG_DIGEST=$(push_blob config.json)
          
          # V√©rifier si le push a r√©ussi
          if [ $? -ne 0 ]; then
            echo "‚ùå √âchec lors de la pouss√©e de la configuration"
            exit 1
          fi
          
          echo "‚úÖ Config digest: $CONFIG_DIGEST"
          
          # Obtenir les tailles des fichiers
          CONFIG_SIZE=$(stat -c %s config.json)
          LAYER_SIZE=$(stat -c %s image.tar.gz)
          
          # Cr√©er le manifest
          echo "üìù Cr√©ation du manifest..."
          MANIFEST_JSON="{
            \"schemaVersion\": 2,
            \"mediaType\": \"application/vnd.docker.distribution.manifest.v2+json\",
            \"config\": {
              \"mediaType\": \"application/vnd.docker.container.image.v1+json\",
              \"size\": ${CONFIG_SIZE},
              \"digest\": \"sha256:${CONFIG_DIGEST}\"
            },
            \"layers\": [
              {
                \"mediaType\": \"application/vnd.docker.image.rootfs.diff.tar.gzip\",
                \"size\": ${LAYER_SIZE},
                \"digest\": \"sha256:${IMAGE_LAYER_DIGEST}\"
              }
            ]
          }"
          
          echo "$MANIFEST_JSON" > manifest.json
          
          # Essayer diff√©rents chemins pour pousser le manifest
          API_PATHS=(
            "$REPO_PATH/v2/manifests/${IMAGE_NAME}:${TAG}"
            "v2/$REPO_PATH/manifests/${IMAGE_NAME}:${TAG}"
            "v2/unify-docker-lsa26/manifests/${IMAGE_NAME}:${TAG}"
          )
          
          success=false
          
          for api_path in "${API_PATHS[@]}"; do
            echo "üîÑ Essai d'envoi du manifest avec le chemin: $api_path"
            
            MANIFEST_RESPONSE=$(curl -v -u $USERNAME:$PASSWORD -X PUT \
              -H "Content-Type: application/vnd.docker.distribution.manifest.v2+json" \
              --data-binary @manifest.json \
              "https://$REGISTRY/$api_path" 2>&1)
              
            echo "üîç R√©ponse du manifest:"
            echo "$MANIFEST_RESPONSE"
            
            # V√©rifier si l'envoi a r√©ussi
            if echo "$MANIFEST_RESPONSE" | grep -q "201 Created"; then
              echo "‚úÖ Manifest envoy√© avec succ√®s via $api_path"
              success=true
              
              # Sauvegarder le chemin d'API qui a fonctionn√©
              WORKING_API_PATH=$api_path
              break
            fi
          done
          
          if [ "$success" != true ]; then
            echo "‚ùå √âchec de l'envoi du manifest apr√®s avoir essay√© tous les chemins"
            exit 1
          fi
          
          # V√©rifier si l'image a √©t√© correctement pouss√©e
          echo "üîç V√©rification de la pr√©sence de l'image..."
          VERIFY_RESPONSE=$(curl -v -u $USERNAME:$PASSWORD \
            "https://$REGISTRY/$WORKING_API_PATH" 2>&1)
            
          echo "üîç R√©ponse de v√©rification:"
          echo "$VERIFY_RESPONSE"
          
          if echo "$VERIFY_RESPONSE" | grep -q "200 OK"; then
            echo "‚úÖ Image trouv√©e apr√®s le push"
          else
            echo "‚ö†Ô∏è Image non confirm√©e apr√®s le push"
          fi
          
          # D√©terminer le chemin complet de l'image en fonction du chemin d'API qui a fonctionn√©
          if [[ "$WORKING_API_PATH" == *"v2/unify-docker-lsa26"* ]]; then
            FULL_IMAGE_PATH="$REGISTRY/unify-docker-lsa26/$IMAGE_NAME:$TAG"
          elif [[ "$WORKING_API_PATH" == *"v2/$REPO_PATH"* ]]; then
            FULL_IMAGE_PATH="$REGISTRY/$REPO_PATH/$IMAGE_NAME:$TAG"
          else
            FULL_IMAGE_PATH="$REGISTRY/$REPO_PATH/$IMAGE_NAME:$TAG"
          fi
          
          echo "üèÅ Image compl√®te: $FULL_IMAGE_PATH"
          echo "$FULL_IMAGE_PATH" > $CLOUDBEES_OUTPUTS/NEXUS_IMAGE
      
      - name: Publish evidence
        uses: cloudbees-io/publish-evidence-item@v1
        with:
          content: |-
            ## Built and pushed image to Nexus
            
            Image Docker pouss√©e avec succ√®s:
            
            **Registry**: ${{ env.DOCKER_REGISTRY }}
            **Repository**: ${{ env.DOCKER_REPO }}
            **Image**: ${{ env.APP_NAME }}:${{ cloudbees.scm.sha }}
            
            Image compl√®te: ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_REPO }}/${{ env.APP_NAME }}:${{ cloudbees.scm.sha }}
          format: MARKDOWN
    needs: test
  
  scan:
    outputs:
      BLOCKER_COUNT: ${{ steps.FetchSonarQubeIssues.outputs.BLOCKER_COUNT }}
      CRITICAL_COUNT: ${{ steps.FetchSonarQubeIssues.outputs.CRITICAL_COUNT }}
      MAJOR_COUNT: ${{ steps.FetchSonarQubeIssues.outputs.MAJOR_COUNT }}
      MINOR_COUNT: ${{ steps.FetchSonarQubeIssues.outputs.MINOR_COUNT }}
    steps:
      - name: Checkout
        uses: cloudbees-io/checkout@v1
      - name: Get code coverage
        kind: test
        uses: docker://node:lts
        run: |
          npm ci --no-audit
          npm run test:coverage
      - uses: cloudbees-io/sonarqube-bundled-sast-scan-code@v1
        name: Scan with SonarQube
        kind: scan
        continue-on-error: true
        with:
          language: LANGUAGE_JS
          cover-file-name: coverage/clover.xml
          sonar-exclusion: tests/*
      - uses: cloudbees-io/snyk-sast-scan-code@v1
        name: Snyk SAST
        kind: scan
        continue-on-error: true
        with:
          orgname: ${{ secrets.SNYK_ORGNAME }}
          token: ${{ secrets.SNYK_TOKEN }}
          language: LANGUAGE_JS
      - name: Scan with Snyk SCA
        uses: cloudbees-io/snyk-sca-scan-dependency@v1
        continue-on-error: true
        with:
          orgname: ${{ secrets.SNYK_ORGNAME }}
          token: ${{ secrets.SNYK_TOKEN }}
          language: LANGUAGE_JS
      - name: Fetch SonarQube Issues
        id: FetchSonarQubeIssues
        uses: docker://alpine/git:latest
        run: |
          apk add --no-cache curl jq
          curl -u ${{ secrets.SONAR_USER }}:${{ secrets.SONAR_TOKEN }} \
          "https://sonarqube.cb-demos.io/api/issues/search?componentKeys=HackersOrganized&severities=BLOCKER,CRITICAL,MAJOR,MINOR" \
          -o sonar-issues.json
          BLOCKER_COUNT=$(jq '[.issues[] | select(.severity=="BLOCKER")] | length' sonar-issues.json)
          CRITICAL_COUNT=$(jq '[.issues[] | select(.severity=="CRITICAL")] | length' sonar-issues.json)
          MAJOR_COUNT=$(jq '[.issues[] | select(.severity=="MAJOR")] | length' sonar-issues.json)
          MINOR_COUNT=$(jq '[.issues[] | select(.severity=="MINOR")] | length' sonar-issues.json)

          echo "${BLOCKER_COUNT}" >> $CLOUDBEES_OUTPUTS/BLOCKER_COUNT
          echo "${CRITICAL_COUNT}" >> $CLOUDBEES_OUTPUTS/CRITICAL_COUNT
          echo "${MAJOR_COUNT}" >> $CLOUDBEES_OUTPUTS/MAJOR_COUNT
          echo "${MINOR_COUNT}" >> $CLOUDBEES_OUTPUTS/MINOR_COUNT
      - name: Publish evidence
        uses: cloudbees-io/publish-evidence-item@v1
        with:
          content: |-
            ## SonarQube Analysis Results

            | Severity             | Issue Count |
            |----------------------|-------------|
            | BLOCKER_COUNT        | ${{ steps.FetchSonarQubeIssues.outputs.BLOCKER_COUNT }} |
            | CRITICAL_COUNT       | ${{ steps.FetchSonarQubeIssues.outputs.CRITICAL_COUNT }} |
            | MAJOR_COUNT          | ${{ steps.FetchSonarQubeIssues.outputs.MAJOR_COUNT }} |
            | MINOR_COUNT          | ${{ steps.FetchSonarQubeIssues.outputs.MINOR_COUNT }} |
          format: MARKDOWN
          
  deploy:
    environment: lsa33
    steps:
      - name: Checkout
        uses: cloudbees-io/checkout@v1
      - uses: cashokannamalai/kubeconfig@v1
        name: Set kubeconfig
        with:
          secname: ${{ secrets.kubeconfig }}
      - id: install-chart
        name: Install helm chart
        uses: cloudbees-io/helm-install@v1
        with:
          chart-location: ${{ cloudbees.workspace }}/chart
          release-name: ${{ env.APP_NAME }}
          namespace: ${{ env.NAMESPACE }}
          values: |
            image:
              repository: ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_REPO }}/${{ env.APP_NAME }}
              tag: ${{ cloudbees.scm.sha }}
            fmKey: ${{ secrets.FM_TOKEN }}
            hostname: ${{ env.APP_NAME }}-${{ env.NAMESPACE }}.preview.cb-demos.io
      - name: Publish evidence
        uses: cloudbees-io/publish-evidence-item@v1
        with:
          content: |-
            ## Deployed environment
            
            ‚úÖ Application d√©ploy√©e avec succ√®s!
            
            [Production frontend](https://${{ env.APP_NAME }}-${{ env.NAMESPACE }}.preview.cb-demos.io/)
            
            Image Docker: ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_REPO }}/${{ env.APP_NAME }}:${{ cloudbees.scm.sha }}
          format: MARKDOWN
      - name: Register deployed artifact
        uses: cloudbees-io/register-deployed-artifact@v1
        with:
          name: ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_REPO }}/${{ env.APP_NAME }}
          version: ${{ cloudbees.scm.sha }}
          url: ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_REPO }}/${{ env.APP_NAME }}:${{ cloudbees.scm.sha }}
          digest: ""
          target-environment: lsa33
    needs:
      - build-and-push-nexus
      - scan
